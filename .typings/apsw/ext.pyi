import abc
import collections.abc
import enum
import logging
import types
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any, Callable, Iterable, Literal, Sequence, TextIO

import apsw
from _typeshed import Incomplete

def result_string(code: int) -> str: ...

class DataClassRowFactory:
    dataclass_kwargs: Incomplete
    rename: Incomplete
    def __init__(self, *, rename: bool = True, dataclass_kwargs: dict[str, Any] | None = None) -> None: ...
    def get_dataclass(self, description: tuple[tuple[str, str], ...]) -> tuple[Any, tuple[str, ...]]: ...
    def get_type(self, t: str | None) -> Any: ...
    def __call__(self, cursor: apsw.Cursor, row: apsw.SQLiteValues) -> Any: ...

class SQLiteTypeAdapter(abc.ABC, metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def to_sqlite_value(self) -> apsw.SQLiteValue: ...

class TypesConverterCursorFactory:
    abstract_base_class: Incomplete
    adapters: Incomplete
    converters: Incomplete
    def __init__(self, abstract_base_class: abc.ABCMeta = ...) -> None: ...
    def register_adapter(self, klass: type, callable: Callable[[Any], apsw.SQLiteValue]) -> None: ...
    def register_converter(self, name: str, callable: Callable[[apsw.SQLiteValue], Any]) -> None: ...
    def __call__(self, connection: apsw.Connection) -> TypeConverterCursor: ...
    def adapt_value(self, value: Any) -> apsw.SQLiteValue: ...
    def convert_value(self, schematype: str, value: apsw.SQLiteValue) -> Any: ...
    def wrap_bindings(self, bindings: apsw.Bindings | None) -> apsw.Bindings | None: ...
    def wrap_sequence_bindings(self, sequenceofbindings: Iterable[apsw.Bindings]) -> Generator[apsw.Bindings, None, None]: ...
    class DictAdapter(collections.abc.Mapping):
        data: Incomplete
        factory: Incomplete
        def __init__(self, factory: TypesConverterCursorFactory, data: collections.abc.Mapping[str, apsw.SQLiteValue]) -> None: ...
        def __getitem__(self, key: str) -> apsw.SQLiteValue: ...
        def __iter__(self): ...
        def __len__(self) -> int: ...
    class TypeConverterCursor(apsw.Cursor):
        factory: Incomplete
        row_trace: Incomplete
        def __init__(self, connection: apsw.Connection, factory: TypesConverterCursorFactory) -> None: ...
        def execute(self, statements: str, bindings: apsw.Bindings | None = None, *, can_cache: bool = True, prepare_flags: int = 0, explain: int = -1) -> apsw.Cursor: ...
        def executemany(self, statements: str, sequenceofbindings: Iterable[apsw.Bindings], *, can_cache: bool = True, prepare_flags: int = 0, explain: int = -1) -> apsw.Cursor: ...

def log_sqlite(*, level: int = ..., logger: logging.Logger | None = None) -> None: ...
def print_augmented_traceback(exc_type: type[BaseException], exc_value: BaseException, exc_traceback: types.TracebackType, *, file: TextIO | None = None) -> None: ...
def index_info_to_dict(o: apsw.IndexInfo, *, column_names: list[str] | None = None, rowid_name: str = '__ROWID__') -> dict[str, Any]: ...
def dbinfo(db: apsw.Connection, schema: str = 'main') -> tuple[DatabaseFileInfo | None, JournalFileInfo | WALFileInfo | None]: ...
def format_query_table(db: apsw.Connection, query: str, bindings: apsw.Bindings | None = None, *, colour: bool = False, quote: bool = False, string_sanitize: Callable[[str], str] | Literal[0] | Literal[1] | Literal[2] = 1, binary: Callable[[bytes], str] = ..., null: str = '(null)', truncate: int = 4096, truncate_val: str = ' ...', text_width: int = 80, use_unicode: bool = True, word_wrap: bool = True) -> str: ...

class VTColumnAccess(enum.Enum):
    By_Index = ...
    By_Name = ...
    By_Attr = ...

def get_column_names(row: Any) -> tuple[Sequence[str], VTColumnAccess]: ...
def make_virtual_module(db: apsw.Connection, name: str, callable: Callable, *, eponymous: bool = True, eponymous_only: bool = False, repr_invalid: bool = False) -> None: ...
def generate_series_sqlite(start: Incomplete | None = None, stop: int = 4294967295, step: int = 1) -> Generator[Incomplete, None, None]: ...
def generate_series(start, stop, step: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
def query_info(db: apsw.Connection, query: str, bindings: apsw.Bindings | None = None, *, prepare_flags: int = 0, actions: bool = False, expanded_sql: bool = False, explain: bool = False, explain_query_plan: bool = False) -> QueryDetails: ...

@dataclass
class QueryDetails:
    query: str
    bindings: apsw.Bindings | None
    first_query: str
    query_remaining: str | None
    is_explain: int
    is_readonly: bool
    has_vdbe: bool
    bindings_count: int
    bindings_names: tuple[str | None]
    description: tuple[tuple[str, str], ...]
    description_full: tuple[tuple[str, str, str, str, str], ...] | None
    expanded_sql: str | None
    actions: list[QueryAction] | None
    explain: list[VDBEInstruction] | None
    query_plan: QueryPlan | None
    def __init__(self, query, bindings, first_query, query_remaining, is_explain, is_readonly, has_vdbe, bindings_count, bindings_names, description, description_full, expanded_sql, actions, explain, query_plan) -> None: ...

@dataclass
class QueryAction:
    action: int
    action_name: str
    column_name: str | None = ...
    database_name: str | None = ...
    file_name: str | None = ...
    function_name: str | None = ...
    module_name: str | None = ...
    operation: str | None = ...
    pragma_name: str | None = ...
    pragma_value: str | None = ...
    table_name: str | None = ...
    trigger_name: str | None = ...
    trigger_or_view: str | None = ...
    view_name: str | None = ...
    def __init__(self, action, action_name, column_name=..., database_name=..., file_name=..., function_name=..., module_name=..., operation=..., pragma_name=..., pragma_value=..., table_name=..., trigger_name=..., trigger_or_view=..., view_name=...) -> None: ...

@dataclass
class QueryPlan:
    detail: str
    sub: list[QueryPlan] | None = ...
    def __init__(self, detail, sub=...) -> None: ...

@dataclass
class VDBEInstruction:
    addr: int
    opcode: str
    comment: str | None = ...
    p1: int | None = ...
    p2: int | None = ...
    p3: int | None = ...
    p4: int | None = ...
    p5: int | None = ...
    def __init__(self, addr, opcode, comment=..., p1=..., p2=..., p3=..., p4=..., p5=...) -> None: ...

@dataclass
class DatabaseFileInfo:
    filename: str
    header: bytes
    page_size: int
    write_format: int
    read_format: int
    reserved_bytes: int
    file_change_counter: int
    page_count: int
    freelist_pages: int
    schema_cookie: int
    schema_format: int
    default_cache_size: int
    autovacuum_top_root: int
    text_encoding: str
    user_version: int
    incremental_vacuum: bool
    application_id: int
    version_valid_for: int
    sqlite_version: int
    def __init__(self, filename, header, page_size, write_format, read_format, reserved_bytes, file_change_counter, page_count, freelist_pages, schema_cookie, schema_format, default_cache_size, autovacuum_top_root, text_encoding, user_version, incremental_vacuum, application_id, version_valid_for, sqlite_version) -> None: ...

@dataclass
class JournalFileInfo:
    filename: str
    header: bytes
    header_valid: bool
    page_count: int
    random_nonce: int
    initial_pages: int
    sector_size: int
    page_size: int
    def __init__(self, filename, header, header_valid, page_count, random_nonce, initial_pages, sector_size, page_size) -> None: ...

@dataclass
class WALFileInfo:
    filename: str
    magic_number: int
    format_version: int
    page_size: int
    checkpoint_sequence_number: int
    salt_1: int
    salt_2: int
    checksum_1: int
    checksum_2: int
    def __init__(self, filename, magic_number, format_version, page_size, checkpoint_sequence_number, salt_1, salt_2, checksum_1, checksum_2) -> None: ...
